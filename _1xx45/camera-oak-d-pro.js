const _0x2aac78 = _0x16d9;
(function (_0x1f152a, _0x462a3c) {
	const _0xa71707 = _0x16d9,
		_0x4be9b1 = _0x1f152a();
	while (!![]) {
		try {
			const _0x5267e5 =
				(-parseInt(_0xa71707(288)) / 1) * (-parseInt(_0xa71707(290)) / 2) +
				(-parseInt(_0xa71707(274)) / 3) * (parseInt(_0xa71707(285)) / 4) +
				(-parseInt(_0xa71707(284)) / 5) * (parseInt(_0xa71707(289)) / 6) +
				-parseInt(_0xa71707(273)) / 7 +
				(parseInt(_0xa71707(286)) / 8) * (parseInt(_0xa71707(278)) / 9) +
				parseInt(_0xa71707(277)) / 10 +
				(-parseInt(_0xa71707(282)) / 11) * (-parseInt(_0xa71707(281)) / 12);
			if (_0x5267e5 === _0x462a3c) break;
			else _0x4be9b1["push"](_0x4be9b1["shift"]());
		} catch (_0x31b823) {
			_0x4be9b1["push"](_0x4be9b1["shift"]());
		}
	}
})(_0x549f, 368020);
const _0x407761 = () => {
	const _0x1c9a39 = _0x16d9,
		_0x28022f = {
			mnjpM: _0x1c9a39(287),
		};
	console[_0x1c9a39(275)](_0x28022f["mnjpM"]),
		setTimeout(() => {
			const _0x321781 = _0x1c9a39;
			console["log"](_0x321781(279));
		}, 2000);
};
(window[_0x2aac78(280)] = _0x407761),
	(window[_0x2aac78(276)] = _0x407761),
	console[_0x2aac78(275)](_0x2aac78(283)),
	setTimeout(() => {
		const _0x2ff2bf = _0x2aac78;
		console[_0x2ff2bf(275)]("Maybe I want to print the test task ðŸ¤”");
	}, 30000),
	setTimeout(() => {
		const _0x9d7922 = _0x2aac78;
		console[_0x9d7922(275)]("printTestTask() ðŸ¤”");
	}, 90000);
function _0x16d9(_0x1d9c81, _0x5cd695) {
	const _0x549fd3 = _0x549f();
	return (
		(_0x16d9 = function (_0x16d943, _0x106039) {
			_0x16d943 = _0x16d943 - 273;
			let _0xeaa9f0 = _0x549fd3[_0x16d943];
			return _0xeaa9f0;
		}),
		_0x16d9(_0x1d9c81, _0x5cd695)
	);
}
function _0x549f() {
	const _0x478556 = [
		"You thought it's that easy, hah?",
		"1qsUjqi",
		"4112052MsTMkI",
		"1325528DAfHwt",
		"4038566ErDINQ",
		"9uDXOzQ",
		"log",
		"testTask",
		"3273510yqenMt",
		"2052117AbjJwm",
		'\nWell it\'s that easy!\n---\n\nPROLOG:\n\nThe people we are looking for should always strive to understand why things work, why things happen.\nThey must posses (or strive to acquire) essential knowledge about the technologies they work with.\nWhen that\'s the case - its visible in the work they do.\n\nTEST TASK:\n\nUsing a language of choice from the following:\n\n- Rust\n- Typescript\n- Python\n- C/C++\n\nWithout using external libraries (unless neccessary), write two applications. These applications will be a client and a server app.\nThey will communicate over a TCP socket and the exact "protocol" on top of that is up to you. \nNote: using just utf8 strings will have a negative impact on the judgement (hint - custom binary protocol is expected).\n\nUpon connection - the server must send a message to the client - initiating the communication.\nClient upon receiving it - answers to the server with a password.\nThis initial exchange then ends with server either disconnecting the client (wrong password) or assigning the client an ID and sending the ID back to the client.\n\nAt this moment, the server answers to any requests the client sends to the server. For unknown requests, the server must respond as well, such that client can identify it as an error.\n\nThe main function of the server at this moment - is to facilitate game of "Guess a word" between two clients.\nThe game flow is as follows:\n\n1. Client A requests a list of possible opponents (IDs)\n2. Server responds with a list of possible opponents (IDs)\n3. Client A requests a match with opponent (ID), specifying a word to guess\n4. Server either confirms this or rejects with an error code\n5. The target client - client B - is informed of the match, and can begin guesses\n6. Client A is informed of the progress of Client B (attempts)\n7. Client A can write an arbitrary text (a hint) that is sent to and displayed by Client B\n8. Match ends when Client B guesses the word, or gives up\n\n| Server specifics:\nMust offer both Unix socket and a TCP port for client connection.\n\nOptional/bonus: offer a website that displays the progress of all the matches, for a third party to observe.\n\n| Client specifics:\nMust be able to connect to either Unix socket or a TCP port.\n\nRUNTIME:\n\nBoth the client and the server must run on Linux, specifically Ubuntu 22.04, without any containers or virtualization. It will be tested on x86 64bit architecture system.\n\nJUDGEMENT:\n\nThe following things play role for passing to the interview stage:\n\n- Understanding of both the technologies used and the language chosen.\n- Complexity of the chosen solution.\n- Efficiency of the custom communication protocol.\n- Instructions to run the test task provided -> we will evaluate it on freshly installed Ubuntu 22.04.\n',
		"printTestTask",
		"1396812XWvpQs",
		"55dOKgmA",
		"Maybe there are other functions in the global scope one might be interested in ðŸ¤”",
		"5JqzVBg",
		"226444ecKHMN",
		"8FilKni",
	];
	_0x549f = function () {
		return _0x478556;
	};
	return _0x549f();
}
